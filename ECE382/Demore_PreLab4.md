### Data types

Go to Table 5-2 (page 76) of the [C Compiler User's Guide](../../datasheets/msp430_optimizing_c_compiler_v4-3.pdf) to complete the following table. For the type, fill in data type that produces a variable of the given size. For max/min values, write in the maximum and minimum values that can be represented with the data type in that row.  Two examples have been given.

| Size | Signed/Unsigned | Type | Min value | Max value |
| :---: | :---: | :---: | :---: | :---: |
| 8-bit | unsigned | unsigned char | 0 | 255 |
| 8-bit | signed | signed char | -128 | 127 |
| 16-bit | unsigned | unsigned short | 0 | 65,535 |
| 16-bit | signed | signed short | -32,768 | 32,767 |
| 32-bit | unsigned | unsigned long | 0 | 4,294,967,295 |
| 32-bit | signed | signed long | -2,147,483,648 | 2,147,483,647 |


When writing embedded C code, it is always a good idea to separate your code from the architecture as much as possible because to make the code easier to change. This is why it is better to use the peripheral register names in your code (e.g. P2IN) rather than their address (e.g. 0x28), and to use peripheral register field names in your code 


Because space is limited on microcontrollers, it is a common practice to use variables with a range suitable for the task at hand. Unfortunately, there is no standard among C compilers between the basic data types like char, short, long and the number of bits in the underlying data representation. Furthermore, when writing and reading code, it is not readily apparent how many bits are in a short or long variable. Consequently, we will write our programs using typed definitions that provide an obvious connection between the data type and the number of bits in the representation. 

In this lab you will be using a library called `stdint` that provides type definitions that clearly indicate the data size and if it is signed or unsigned.  The following is an excerpt from the library:

    typedef   signed char    int8_t;
    typedef unsigned char   uint8_t;
    typedef          int    int16_t;
    typedef unsigned int   uint16_t;
    typedef          long   int32_t;
    typedef unsigned long  uint32_t;

### Calling/Return Convention

Make a test project named **Lab4_Prelab** and use [simpleLab4.c](simpleLab4.c) as the main file. While the functioning of the program is not really that important, let's first take some time to understand what is going on in this program before we look at the underlying assembly language. Use CCS to step through the program and examine the a, b, c, d, e variables in main, just *after* the call to the function `func` in line 18.  Fill in the values for each variable in the table below for the first five iterations of the while loop.

| Iteration | a | b | c | d | e |
| :---: | :---: | :---: | :---: | :---:| :---: |
| 1st | 2 | 2 | 3 | 4 | 2 | 
| 2nd | 8 | 9 | 8 | 7 | 8 | 
| 3rd | 14 | 15 | 14 | 13 | 14 | 
| 4th | 20 | 21 | 20 | 19 | 20 | 
| 5th | 26 | 27 | 26 | 25 | 26 |

Now examine the assembly code generated by the compiler by selecting the View -> Disassembly menu item. You should see the disassembly window as a selectable tab in the subwindow where your registers are displayed. To fill in the following table with the appropriate values, you have a few tasks:

1) First, find the code for the function `func` and write down the starting and ending address in the table below. 

2) Next, identify which registers are used to pass the input parameters from main to the function. Write their identities below. If it is not clear which register holds which input parameter, test it out!  Go ahead and change the code, so that `func` only has one input parameter, recompile the code, and then examine the assembly. 

3) Finally, determine which register is used to return the value from func to main.

| Parameter | Value Sought |
| :---: | :---: |
| Starting address of `func` | 0xC044 |
| Ending address of `func` | 0xC050 |
| Register holding w | R12 |
| Register holding x | R13 |
| Register holding y | R14 |
| Register holding z | R15 |
| Register holding return value | R12 |

### Cross language build constructs

**Answer the following questions:**

**Question 1:**  What is the role of the `extern` directive in a .c file?  *Hint:* check out the [external variable](http://en.wikipedia.org/wiki/External_variable) Wikipedia page.
<br><br>
'extern' declares a variable without defining it outside of a function.
<br><br>

**Question 2:**  What is the role of the `.global` directive in an .asm file (used in lines 60-64)?  Hint: reference section 2.6.2 in the MSP 430 Assembly Language Tools v4.3 User's Guide.
<br><br>
'.global' allows the assembler to use either .def or .ref for the variable, depending on its use.
<br><br>
